<!DOCTYPE html>
<html>

<head>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="preconnect" href="https://fonts.gstatic.com/" crossorigin />
  <link rel="stylesheet" as="style" onload="this.rel='stylesheet'"
    href="https://fonts.googleapis.com/css2?display=swap&family=Inter:wght@400;500;700;900&family=Noto+Sans:wght@400;500;700;900" />
  <title>Send Funds - ZK FacePay</title>
  <link rel="icon" type="image/x-icon" href="data:image/x-icon;base64," />
  <script src="/face-api.js"></script>
  <script src="/js/commons.js"></script>
  <script src="/js/faceDetectionControls.js"></script>
  <script src="https://cdn.tailwindcss.com?plugins=forms,container-queries"></script>
  <script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js"></script>
  <style>
    .video-container {
      position: relative;
      width: 100%;
    }

    #inputVideo,
    #overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
    }
  </style>
</head>

<body>
  <div
    class="min-h-screen bg-gradient-to-br from-slate-900 via-purple-900 to-slate-900 flex items-center justify-center p-4"
    style='font-family: Inter, "Noto Sans", sans-serif;'>
    <div class="w-full max-w-md">
      <button onclick="window.location.href='/'"
        class="flex items-center text-white mb-4 gap-2 hover:text-purple-300 transition-colors"
        style="background: none; border: none;">
        <svg xmlns="http://www.w3.org/2000/svg" class="w-4 h-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7" />
        </svg>
        Back
      </button>
      <div class="bg-white/10 backdrop-blur-lg border border-white/20 rounded-2xl shadow-lg p-8">
        <h2 class="text-white text-2xl font-bold text-center mb-2">Send Funds</h2>
        <h3 class="text-white text-xl font-semibold text-center mb-3">Capture Recipient's Face</h3>
        <p class="text-slate-300 text-base text-center mb-6">Ensure the recipient's face is fully visible within the
          viewfinder for accurate recognition.</p>
        <div class="flex w-full grow justify-center mb-4">
          <div class="w-full max-w-xs aspect-[2/3] rounded-lg flex items-center justify-center video-container relative"
            style="height: 320px; max-width: 100vw;">
            <video id="inputVideo" autoplay muted playsinline
              class="rounded-lg bg-black w-full h-full object-cover"></video>
            <canvas id="overlay" class="rounded-lg w-full h-full absolute top-0 left-0"></canvas>
            <img id="inputImage" class="rounded-lg bg-black w-full h-full object-cover absolute top-0 left-0 hidden" />
          </div>
        </div>
        <div class="flex justify-center items-center mb-2">
          <input type="file" id="uploadPhoto" accept="image/*" disabled
            class="block w-full max-w-xs text-sm text-slate-500 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-blue-50 file:text-blue-700 hover:file:bg-blue-100" />
        </div>
        <div class="flex w-full">
          <button id="captureBtn"
            class="w-full rounded-lg h-12 bg-gradient-to-r from-blue-500 to-purple-500 hover:from-blue-600 hover:to-purple-600 text-white text-base font-bold transition-colors"
            disabled>
            Capture Image
          </button>
        </div>
        <div id="embeddings-container" class="hidden flex flex-col items-center justify-center py-6">
          <div class="text-blue-400 text-xl font-bold mb-2">Face Embeddings</div>
          <textarea id="embeddings-output" class="font-mono text-xs border rounded px-2 py-1 w-80 h-32"
            readonly></textarea>
          <button id="copy-embeddings"
            class="bg-gradient-to-r from-blue-500 to-purple-500 text-white rounded px-2 py-1 text-xs mt-2">Copy
            Embeddings</button>
          <div id="copy-embeddings-status" class="text-xs text-green-400 mt-1 hidden">Copied!</div>
        </div>
        <div id="send-funds-container" class="hidden flex flex-col items-center justify-center py-6">
          <div class="text-white text-xl font-bold mb-2">Send ETH to Recipient</div>
          <button id="connect-wallet"
            class="mb-4 px-4 py-2 bg-gradient-to-r from-green-500 to-blue-500 text-white rounded font-bold">Connect
            Wallet</button>
          <div id="wallet-address" class="text-slate-300 text-xs mb-4 hidden"></div>
          <div class="flex flex-col gap-2 w-full max-w-xs mb-4">
            <label class="text-slate-200 text-sm">Amount in ETH</label>
            <input id="eth-amount-input" type="number" min="0.000001" step="any" class="rounded px-2 py-1 w-full"
              placeholder="Enter amount in ETH" />
          </div>
          <button id="send-eth"
            class="w-full rounded-lg h-12 bg-gradient-to-r from-blue-500 to-purple-500 hover:from-blue-600 hover:to-purple-600 text-white text-base font-bold transition-colors"
            disabled>Send</button>
          <div id="send-status" class="text-xs text-green-400 mt-2 hidden"></div>
          <div id="send-error" class="text-xs text-red-400 mt-2 hidden"></div>
        </div>
        <div id="claim-link-container" class="hidden flex flex-col items-center justify-center py-6">
          <div class="text-green-400 text-xl font-bold mb-2">Face captured!</div>
          <div class="text-white text-base font-normal mb-2">Share this link with the recipient to claim their funds:
          </div>
          <div class="flex items-center gap-2">
            <input id="claim-link"
              class="font-mono text-xs border rounded px-2 py-1 w-64 bg-white/10 border-white/20 text-white" readonly />
            <button id="copy-link"
              class="bg-gradient-to-r from-blue-500 to-purple-500 text-white rounded px-2 py-1 text-xs">Copy</button>
          </div>
          <div id="copy-status" class="text-xs text-green-400 mt-1 hidden">Copied!</div>
        </div>
        <div id="face-status" class="text-center text-red-400 font-semibold"></div>
      </div>
    </div>
  </div>
  <script>
    let stream;
    let isModelLoaded = false;
    async function startWebcam() {
      const videoEl = document.getElementById('inputVideo');
      try {
        // Use the front (selfie) camera by default
        stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'user' } });
      } catch (err) {
        // fallback to any camera
        stream = await navigator.mediaDevices.getUserMedia({ video: true });
      }
      videoEl.srcObject = stream;
    }
    async function loadModels() {
      await faceapi.nets.tinyFaceDetector.load('/models/');
      await faceapi.nets.faceRecognitionNet.load('/models/');
      isModelLoaded = true;
      document.getElementById('uploadPhoto').disabled = false;
      document.getElementById('captureBtn').disabled = false;
    }
    async function detectFace(sourceType = 'video') {
      const canvas = document.getElementById('overlay');
      let input, displaySize;
      if (sourceType === 'image') {
        input = document.getElementById('inputImage');
        displaySize = { width: input.naturalWidth, height: input.naturalHeight };
      } else {
        input = document.getElementById('inputVideo');
        displaySize = { width: input.videoWidth, height: input.videoHeight };
      }
      faceapi.matchDimensions(canvas, displaySize);
      const detection = await faceapi.detectSingleFace(input, new faceapi.TinyFaceDetectorOptions());
      const resizedDetections = detection ? faceapi.resizeResults(detection, displaySize) : null;
      canvas.getContext('2d').clearRect(0, 0, canvas.width, canvas.height);
      if (resizedDetections) {
        faceapi.draw.drawDetections(canvas, resizedDetections);
      }
      return detection;
    }
    // Helper function to check if an image is loaded (from face-api.js isMediaLoaded)
    function isImageLoaded(img) {
      return img.complete;
    }
    document.addEventListener('DOMContentLoaded', async () => {
      await loadModels();
      await startWebcam();
      const inputImage = document.getElementById('inputImage');
      const inputVideo = document.getElementById('inputVideo');
      document.getElementById('uploadPhoto').addEventListener('change', async function (e) {
        const file = e.target.files[0];
        if (!file) return;
        const url = URL.createObjectURL(file);
        inputImage.src = url;
        inputImage.onload = async () => {
          inputImage.classList.remove('hidden');
          inputVideo.classList.add('hidden');
          if (!isImageLoaded(inputImage)) {
            console.warn('Uploaded image is not fully loaded, skipping detection.');
            return;
          }
          const detection = await detectFace('image');
          const status = document.getElementById('face-status');
          if (detection) {
            status.textContent = '';
            document.getElementById('captureBtn').style.display = 'none';
            const descriptor = await faceapi.computeFaceDescriptor(inputImage);
            const embeddingsOutput = document.getElementById('embeddings-output');
            if (embeddingsOutput) {
              embeddingsOutput.value = JSON.stringify(Array.from(descriptor), null, 2);
              // Skip embeddings-container, go directly to send funds
              document.getElementById('embeddings-container').classList.add('hidden');
              showSendFunds();
            } else {
              console.warn('Embeddings output not found in DOM');
            }
          } else {
            status.textContent = 'No face detected in uploaded photo. Try another image.';
            inputImage.classList.add('hidden');
            inputVideo.classList.remove('hidden');
          }
        };
      });
      document.getElementById('captureBtn').onclick = async () => {
        if (!isModelLoaded) return;
        let detection;
        if (!inputImage.classList.contains('hidden')) {
          detection = await detectFace('image');
        } else {
          detection = await detectFace('video');
        }
        const status = document.getElementById('face-status');
        if (detection) {
          status.textContent = '';
          document.getElementById('captureBtn').style.display = 'none';
          let descriptor;
          if (!inputImage.classList.contains('hidden')) {
            descriptor = await faceapi.computeFaceDescriptor(inputImage);
          } else {
            descriptor = await faceapi.computeFaceDescriptor(inputVideo);
          }
          const embeddingsOutput = document.getElementById('embeddings-output');
          if (embeddingsOutput) {
            embeddingsOutput.value = JSON.stringify(Array.from(descriptor), null, 2);
            // Skip embeddings-container, go directly to send funds
            document.getElementById('embeddings-container').classList.add('hidden');
            showSendFunds();
          } else {
            console.warn('Embeddings output not found in DOM');
          }
          if (stream && inputImage.classList.contains('hidden')) stream.getTracks().forEach(t => t.stop());
        } else {
          status.textContent = 'No face detected. Try again.';
        }
      };
    });
    // --- New wallet/ETH logic ---
    let userAddress = null;
    let provider, signer;
    const CHAIN_ID = '0x6706e'; // 421614 in hex
    const RPC_URL = 'https://sepolia-rollup.arbitrum.io/rpc';
    // Show send funds UI after embeddings
    function showSendFunds() {
      document.getElementById('embeddings-container').classList.add('hidden');
      document.getElementById('send-funds-container').classList.remove('hidden');
    }
    // Connect wallet
    document.getElementById('connect-wallet').onclick = async function () {
      if (window.ethereum) {
        let switched = false;
        try {
          await window.ethereum.request({ method: 'wallet_switchEthereumChain', params: [{ chainId: CHAIN_ID }] });
          switched = true;
        } catch (switchError) {
          if (switchError.code === 4902) {
            // Chain not added, try to add
            try {
              await window.ethereum.request({
                method: 'wallet_addEthereumChain',
                params: [{
                  chainId: CHAIN_ID,
                  rpcUrls: [RPC_URL],
                  chainName: 'Arbitrum Sepolia',
                  nativeCurrency: { name: 'ETH', symbol: 'ETH', decimals: 18 },
                  blockExplorerUrls: ['https://sepolia.arbiscan.io/']
                }]
              });
              switched = true;
            } catch (addError) {
              document.getElementById('send-error').textContent = 'Failed to add network.';
              document.getElementById('send-error').classList.remove('hidden');
              return;
            }
          } else if (switchError.code === 4001) {
            // User rejected
            document.getElementById('send-error').textContent = 'Network switch rejected by user.';
            document.getElementById('send-error').classList.remove('hidden');
            return;
          } // else: could be already on correct network, so continue
        }
        // Always try to connect wallet and show address
        try {
          const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' });
          userAddress = accounts[0];
          document.getElementById('wallet-address').textContent = 'Connected: ' + userAddress;
          document.getElementById('wallet-address').classList.remove('hidden');
          document.getElementById('send-eth').disabled = false;
          document.getElementById('send-error').classList.add('hidden');
        } catch (connectError) {
          document.getElementById('send-error').textContent = 'Wallet connection rejected.';
          document.getElementById('send-error').classList.remove('hidden');
        }
      } else {
        document.getElementById('send-error').textContent = 'MetaMask not found.';
        document.getElementById('send-error').classList.remove('hidden');
      }
    };

    // Send ETH and call contract
    document.getElementById('send-eth').onclick = async function () {
      document.getElementById('send-status').classList.add('hidden');
      document.getElementById('send-error').classList.add('hidden');
      const eth = parseFloat(document.getElementById('eth-amount-input').value);
      if (!userAddress || !eth || eth <= 0) {
        document.getElementById('send-error').textContent = 'Please connect wallet and enter a valid ETH amount.';
        document.getElementById('send-error').classList.remove('hidden');
        return;
      }
      // Get face embeddings
      let embeddings;
      try {
        embeddings = JSON.parse(document.getElementById('embeddings-output').value);
      } catch (e) {
        document.getElementById('send-error').textContent = 'Invalid embeddings.';
        document.getElementById('send-error').classList.remove('hidden');
        return;
      }
      // Pad/convert embeddings to bytes32[128]
      let faceEncoding = [];
      for (let i = 0; i < 128; i++) {
        let hex;
        if (i < embeddings.length) {
          let val = embeddings[i];
          let intVal = Math.floor(val * Math.pow(2, 32));
          let bigVal = BigInt(intVal);
          if (bigVal < 0n) {
            bigVal = (1n << 256n) + bigVal;
          }
          hex = bigVal.toString(16).padStart(64, '0');
          faceEncoding.push('0x' + hex);
        } else {
          faceEncoding.push('0x' + '00'.repeat(32));
        }
      }
      // Generate a salt as bytes32
      // Use ethers.utils.formatBytes32String to convert a string to bytes32
      let salt;
      try {
        // Generate a random 16-byte hex string and format as bytes32
        // Use a 31-character string to ensure it's less than 32 bytes for formatBytes32String
        const randomBytes = crypto.getRandomValues(new Uint8Array(16));
        // Convert to base64 (22 chars for 16 bytes), safe for bytes32
        const randomBase64 = btoa(String.fromCharCode(...randomBytes)).replace(/=+$/, '').slice(0, 31);
        salt = window.ethers.utils.formatBytes32String(randomBase64);
      } catch (e) {
        document.getElementById('send-error').textContent = 'Failed to format salt: ' + (e.message || e);
        document.getElementById('send-error').classList.remove('hidden');
        return;
      }
      // Contract ABI and address (replace with your deployed address)
      const CONTRACT_ABI = [
        { "anonymous": false, "inputs": [{ "indexed": false, "internalType": "address", "name": "addr", "type": "address" }], "name": "Deployed", "type": "event" },
        { "inputs": [{ "internalType": "bytes32", "name": "salt", "type": "bytes32" }, { "internalType": "address", "name": "owner", "type": "address" }, { "internalType": "bytes32[128]", "name": "faceEncoding", "type": "bytes32[128]" }], "name": "deploy", "outputs": [{ "internalType": "address", "name": "addr", "type": "address" }], "stateMutability": "payable", "type": "function" },
        { "inputs": [{ "internalType": "bytes32", "name": "salt", "type": "bytes32" }, { "internalType": "address", "name": "owner", "type": "address" }, { "internalType": "bytes32[128]", "name": "faceEncoding", "type": "bytes32[128]" }], "name": "getAddress", "outputs": [{ "internalType": "address", "name": "", "type": "address" }], "stateMutability": "view", "type": "function" },
        { "inputs": [{ "internalType": "address", "name": "owner", "type": "address" }, { "internalType": "bytes32[128]", "name": "faceEncoding", "type": "bytes32[128]" }], "name": "getBytecode", "outputs": [{ "internalType": "bytes", "name": "", "type": "bytes" }], "stateMutability": "pure", "type": "function" }
      ];
      const CONTRACT_ADDRESS = '0x86E5dE549fBF9a8cE9f4086259ecC1E66810f18b';
      // Use ethers.js if available
      if (window.ethereum && window.ethers) {
        provider = new window.ethers.providers.Web3Provider(window.ethereum, 'any');
        signer = provider.getSigner();
        const contract = new window.ethers.Contract(CONTRACT_ADDRESS, CONTRACT_ABI, signer);
        try {
          console.log("deploying contract");
          console.log("Salt:", salt);
          console.log("Owner:", "0xb18038a8cbb3001E79f75adb8c79852eae0f4CeC");
          console.log("FaceEncoding:", faceEncoding);
          console.log("ETH amount:", eth);
          console.log("Value (wei):", window.ethers.utils.parseEther(eth.toString()).toString());

          // Use a high manual gas limit
          const manualGasLimit = 8000000;
          const tx = await contract.deploy(
            salt,
            "0xb18038a8cbb3001E79f75adb8c79852eae0f4CeC",
            faceEncoding,
            {
              // value: window.ethers.utils.parseEther(eth.toString()),
              gasLimit: manualGasLimit
            },
          );
          console.log("Transaction sent to blockchain. Tx hash:", tx.hash);
          document.getElementById('send-status').textContent = 'Transaction sent. Waiting for confirmation...';
          document.getElementById('send-status').classList.remove('hidden');
          const receipt = await tx.wait();
          if (receipt && receipt.status === 1) {
            console.log("Transaction confirmed on blockchain. Receipt:", receipt);
          } else {
            console.log("Transaction failed or was reverted. Receipt:", receipt);
          }
          // Get deployed address from event or call getAddress
          let deployedAddr = null;
          if (receipt && receipt.events) {
            const event = receipt.events.find(e => e.event === 'Deployed');
            if (event) deployedAddr = event.args.addr;
          }
          if (!deployedAddr) {
            deployedAddr = await contract.getAddress(salt, "0xb18038a8cbb3001E79f75adb8c79852eae0f4CeC", faceEncoding);
          }
          // Show success and link
          document.getElementById('send-funds-container').classList.add('hidden');
          document.getElementById('claim-link-container').classList.remove('hidden');
          const claimUrl = `${window.location.origin}/receive?address=${deployedAddr}&amount=${eth}ETH`;
          document.getElementById('claim-link').value = claimUrl;
          document.getElementById('copy-link').onclick = function () {
            navigator.clipboard.writeText(claimUrl);
            document.getElementById('copy-status').classList.remove('hidden');
            setTimeout(() => document.getElementById('copy-status').classList.add('hidden'), 1200);
          };
        } catch (err) {
          console.error("Transaction failed to send to blockchain:", err);
          document.getElementById('send-error').textContent = 'Transaction failed: ' + (err.message || err);
          document.getElementById('send-error').classList.remove('hidden');
        }
      } else {
        console.error("Ethers.js or MetaMask not found.");
        document.getElementById('send-error').textContent = 'Ethers.js or MetaMask not found.';
        document.getElementById('send-error').classList.remove('hidden');
      }
    };

    // Enable/disable send button based on ETH input
    document.getElementById('eth-amount-input').addEventListener('input', function () {
      const eth = parseFloat(this.value);
      document.getElementById('send-eth').disabled = !(eth > 0 && userAddress);
    });

    // Show send funds UI after embeddings are generated
    // Patch into existing embedding logic
    const origShowEmbeddings = function () {
      document.getElementById('embeddings-container').classList.remove('hidden');
      showSendFunds();
    };
    // Patch: after embeddings are shown, also show send funds
    // You may need to call origShowEmbeddings() after embeddings are generated in your flow
  </script>
</body>

</html>