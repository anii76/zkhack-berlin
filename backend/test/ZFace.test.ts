import fs from "fs";
import { expect } from "chai";
import hre, { ethers } from "hardhat";
import { HonkVerifier } from "../typechain-types";
import { BytesLike } from "ethers";

function quantize(value: number): bigint {
  // Convert a floating-point number to a quantized integer
  // Scale to 16-bit precision and handle negative numbers
  const scaled = Math.floor(value * (2 ** 16));
  // Handle negative numbers using the field prime p
  const p = BigInt("21888242871839275222246405745257275088548364400416034343698204186575808495616");
  if (scaled < 0) {
    return p + BigInt(scaled);
  }
  return BigInt(scaled);
}

function quantizedToBytes32(value: bigint): BytesLike {
  // Convert quantized value to bytes32 representation
  // Handle BigInt values properly
  const hex = value.toString(16).padStart(64, '0'); // Convert to hex and pad to 32 bytes
  const buffer = new Uint8Array(32);
  for (let i = 0; i < 32; i++) {
    buffer[i] = parseInt(hex.substr(i * 2, 2), 16);
  }
  return buffer;
}

// Create test face embeddings (quantized values)
const faceA1 = [
  -0.0420333668589592,
  0.08858506381511688,
  0.04610809311270714,
  -0.015131408348679543,
  -0.040366511791944504,
  -0.08012647926807404,
  0.011909302324056625,
  -0.10284213721752167,
  0.06631620228290558,
  -0.04723583161830902,
  0.2417113333940506,
  -0.0706089660525322,
  -0.24034473299980164,
  -0.09126384556293488,
  0.023397790268063545,
  0.10509838908910751,
  -0.09766107052564621,
  -0.02783375419676304,
  -0.14377769827842712,
  -0.09013804793357849,
  -0.021886538714170456,
  0.013537299819290638,
  -0.009127178229391575,
  0.00147919449955225,
  -0.05781606584787369,
  -0.2618850767612457,
  -0.07463926076889038,
  -0.11075849086046219,
  0.0214167982339859,
  -0.09634008258581161,
  0.033587001264095306,
  0.10152768343687057,
  -0.150453120470047,
  -0.07698308676481247,
  0.007288703694939613,
  0.030696777626872063,
  -0.01446785032749176,
  -0.04744728282094002,
  0.21160359680652618,
  -0.02038559503853321,
  -0.09975316375494003,
  -0.03207547962665558,
  0.021688343957066536,
  0.23213541507720947,
  0.15207378566265106,
  -0.01321379840373993,
  -0.0001142007386079058,
  -0.03949315473437309,
  0.06636941432952881,
  -0.24475184082984924,
  -0.017264526337385178,
  0.10756488889455795,
  0.07615610212087631,
  0.09490623325109482,
  0.035728346556425095,
  -0.08833442628383636,
  0.04740332439541817,
  0.061874471604824066,
  -0.22800977528095245,
  0.025262942537665367,
  0.029978295788168907,
  -0.18777139484882355,
  -0.11278564482927322,
  -0.06771191954612732,
  0.18138468265533447,
  0.11802808195352554,
  -0.04601255804300308,
  -0.08431294560432434,
  0.18765662610530853,
  -0.15176378190517426,
  -0.041040655225515366,
  0.047886352986097336,
  -0.08537561446428299,
  -0.133330836892128,
  -0.2555219829082489,
  0.06692547351121902,
  0.3215359151363373,
  0.15939846634864807,
  -0.16250720620155334,
  0.015089555643498898,
  -0.07670304924249649,
  -0.051101330667734146,
  0.06629395484924316,
  0.00617410009726882,
  -0.03150379657745361,
  -0.048648327589035034,
  -0.014047362841665745,
  0.09447088092565536,
  0.1643708497285843,
  -0.08047662675380707,
  0.008535473607480526,
  0.1930290162563324,
  -0.03774581104516983,
  0.00994698517024517,
  0.010746008716523647,
  -0.03215905651450157,
  -0.0029994333162903786,
  -0.010443659499287605,
  -0.06891985237598419,
  0.05016385763883591,
  0.13585351407527924,
  -0.1557251363992691,
  0.07092173397541046,
  0.08362264186143875,
  -0.19094383716583252,
  0.09215099364519119,
  0.0020038948860019445,
  -0.05202881991863251,
  0.07388570159673691,
  -0.027980731800198555,
  -0.03879208117723465,
  -0.016325924545526505,
  0.20777460932731628,
  -0.20537148416042328,
  0.2577527165412903,
  0.1715632826089859,
  -0.053133998066186905,
  0.10044895857572556,
  -0.011720790527760983,
  0.10758786648511887,
  -0.03162064030766487,
  -0.07451781630516052,
  -0.1427411437034607,
  -0.08947712928056717,
  0.058415886014699936,
  0.02985125407576561,
  -0.005884265527129173,
  -0.003557865507900715
]
.map(quantize);
const faceA1Bytes: BytesLike[] = faceA1.map(quantizedToBytes32);

const faceA2 = [
  -0.08908695727586746,
  0.10642766952514648,
  0.06451733410358429,
  -0.03319132700562477,
  -0.04769820347428322,
  -0.10886412113904953,
  -0.0017827582778409123,
  -0.1266949325799942,
  0.09231531620025635,
  -0.05398135259747505,
  0.2562599182128906,
  -0.05666384845972061,
  -0.24022671580314636,
  -0.07672243565320969,
  -0.005710997618734837,
  0.11887064576148987,
  -0.10954512655735016,
  -0.0482717826962471,
  -0.11091730743646622,
  -0.08136850595474243,
  -0.005326117854565382,
  0.00291448924690485,
  -0.02772030234336853,
  0.0007800237508490682,
  -0.07392037659883499,
  -0.2741489112377167,
  -0.09315595775842667,
  -0.1012461930513382,
  -0.014575106091797352,
  -0.07528328150510788,
  0.02490777149796486,
  0.10462042689323425,
  -0.16050836443901062,
  -0.08768346905708313,
  0.0017242284957319498,
  0.020440740510821342,
  0.0016303358133882284,
  -0.03896298259496689,
  0.1667962223291397,
  -0.0298428013920784,
  -0.10463254153728485,
  -0.03789306432008743,
  0.011842907406389713,
  0.22121727466583252,
  0.1541292667388916,
  0.005734016187489033,
  0.005169603507965803,
  -0.06799226254224777,
  0.03723959997296333,
  -0.23877421021461487,
  -0.03556543588638306,
  0.09653327614068985,
  0.010047867894172668,
  0.08117608726024628,
  0.016338784247636795,
  -0.09706758707761765,
  0.026944473385810852,
  0.058572396636009216,
  -0.2076423019170761,
  -0.0010784058831632137,
  0.017307134345173836,
  -0.19812291860580444,
  -0.126267671585083,
  -0.07703661173582077,
  0.19995097815990448,
  0.12324152886867523,
  -0.05286150425672531,
  -0.08941442519426346,
  0.20011670887470245,
  -0.14212195575237274,
  -0.045629095286130905,
  0.031982939690351486,
  -0.08713629096746445,
  -0.14047576487064362,
  -0.2594677805900574,
  0.07738173753023148,
  0.3423137068748474,
  0.1450345665216446,
  -0.15360237658023834,
  0.03986703231930733,
  -0.10274047404527664,
  -0.0360322929918766,
  0.0692850723862648,
  0.003079477231949568,
  -0.007426554802805185,
  -0.044285066425800323,
  -0.029815398156642914,
  0.07350417971611023,
  0.1825920194387436,
  -0.07679568231105804,
  0.014073818922042847,
  0.20641639828681946,
  -0.05137186124920845,
  0.02632935717701912,
  0.013308709487318993,
  -0.013328712433576584,
  -0.015235786326229572,
  -0.004156269133090973,
  -0.07631734758615494,
  0.02548660896718502,
  0.14389635622501373,
  -0.10620763152837753,
  0.05034247413277626,
  0.11152251809835434,
  -0.17435762286186218,
  0.07070904225111008,
  0.005711205303668976,
  -0.03802729770541191,
  0.06832581013441086,
  -0.03434403985738754,
  -0.020632602274417877,
  -0.05416383221745491,
  0.18366388976573944,
  -0.192613422870636,
  0.2482515126466751,
  0.17665429413318634,
  -0.043211549520492554,
  0.11673325300216675,
  -0.003660753834992647,
  0.08033370971679688,
  -0.031626250594854355,
  -0.07204151898622513,
  -0.1526617556810379,
  -0.06695681065320969,
  0.08305086195468903,
  0.025828290730714798,
  -0.009008948691189289,
  -0.007564002647995949
].map(quantize);
const faceA2Bytes: BytesLike[] = faceA1.map(quantizedToBytes32);

const faceB = [
  -0.09373191744089127,
  0.1104452982544899,
  0.052237559109926224,
  -0.02158139832317829,
  -0.11502562463283539,
  -0.06254788488149643,
  0.000541282759513706,
  -0.04457005858421326,
  0.12921954691410065,
  -0.02420775406062603,
  0.19017358124256134,
  0.008041052147746086,
  -0.2786053717136383,
  -0.029471559450030327,
  -0.012000332586467266,
  0.09437356889247894,
  -0.11470577865839005,
  -0.03433937579393387,
  -0.1547534167766571,
  -0.16401441395282745,
  0.004454849287867546,
  -0.0113667668774724,
  -0.007668912410736084,
  -0.036760009825229645,
  -0.07344219088554382,
  -0.2786152958869934,
  -0.08469036221504211,
  -0.07093614339828491,
  0.08083465695381165,
  -0.15078189969062805,
  0.05071685463190079,
  0.03527536243200302,
  -0.14009229838848114,
  -0.0788278728723526,
  -0.03267859295010567,
  0.047114502638578415,
  -0.05407194420695305,
  -0.09653320163488388,
  0.1853768527507782,
  -0.06155205890536308,
  -0.07147569954395294,
  0.017114069312810898,
  0.04527251049876213,
  0.24872393906116486,
  0.18611200153827667,
  0.03106686659157276,
  0.059685513377189636,
  -0.0679844468832016,
  0.13539548218250275,
  -0.29471835494041443,
  0.04154590889811516,
  0.12172696739435196,
  0.021980684250593185,
  0.10923539102077484,
  0.09547676146030426,
  -0.1491054743528366,
  0.043879833072423935,
  0.0979243814945221,
  -0.1220792606472969,
  0.0824623554944992,
  0.09549745172262192,
  -0.1487988382577896,
  -0.12166100740432739,
  -0.1234116330742836,
  0.18631307780742645,
  0.054698213934898376,
  -0.08487557619810104,
  -0.0735761895775795,
  0.14651764929294586,
  -0.16736826300621033,
  0.0018550808308646083,
  0.053759753704071045,
  -0.08410928398370743,
  -0.12161201983690262,
  -0.2680170238018036,
  0.13867458701133728,
  0.41687852144241333,
  0.18680749833583832,
  -0.11397051066160202,
  0.014882690273225307,
  -0.09315252304077148,
  0.00009385809244122356,
  0.048703569918870926,
  0.023861639201641083,
  -0.08130781352519989,
  -0.09972267597913742,
  -0.10066267848014832,
  0.07672951370477676,
  0.1871720552444458,
  -0.04939356818795204,
  0.030376795679330826,
  0.1904335618019104,
  0.03906454145908356,
  0.04325481876730919,
  -0.02330387756228447,
  0.030589133501052856,
  -0.1175091564655304,
  -0.050483014434576035,
  -0.018088793382048607,
  0.05785727873444557,
  0.13935884833335876,
  -0.2053259313106537,
  0.022262226790189743,
  0.07103410363197327,
  -0.15560787916183472,
  0.1460900902748108,
  -0.02772071585059166,
  0.01520245335996151,
  0.056368086487054825,
  -0.027316821739077568,
  -0.03361072018742561,
  -0.008768408559262753,
  0.19724896550178528,
  -0.22414587438106537,
  0.21992823481559753,
  0.2094046175479889,
  -0.031203921884298325,
  0.1425531953573227,
  0.012498868629336357,
  0.16764415800571442,
  -0.05673383176326752,
  -0.0039925239980220795,
  -0.12293794006109238,
  -0.0773254856467247,
  -0.030100194737315178,
  -0.001376543310470879,
  -0.044246673583984375,
  0.04001055285334587
].map(quantize);;
const faceBBytes: BytesLike[] = faceB.map(quantizedToBytes32);

// Set threshold for similarity (sum of squared differences)
const threshold = BigInt(300_000_000); // Adjust based on your similarity requirements
const thresholdBytes = quantizedToBytes32(threshold);

// Make Prover.toml
const probeFace = faceA2.map(v => `[[probeFace]]\nx = "${v.toString()}"\n`).join("\n");
const referenceFace = faceA1.map(v => `[[referenceFace]]\nx = "${v.toString()}"\n`).join("\n");
const thresholdStr = `threshold = "${threshold.toString()}"`;
const proverToml = `# Prover.toml for ZFace Verifier Circuit
${probeFace}
${referenceFace}
${thresholdStr}
`
fs.writeFileSync("noir/zface_verifier/Prover.toml", proverToml);

let verifierContract: HonkVerifier;
before(async () => {
  verifierContract = await ethers.deployContract("HonkVerifier");
})

it("has correct face embeddings", () => {
  expect(faceA1).to.have.length(128);
  expect(faceA2).to.have.length(128);
  expect(faceB).to.have.length(128);

  function sumSquaredDifferences(face1: bigint[], face2: bigint[]): bigint {
    const p = BigInt("21888242871839275222246405745257275088548364400416034343698204186575808495616");
    const halfP = p / BigInt(2);
    
    return face1.reduce((sum, value, index) => {
      let diff = value - face2[index];
      
      // Handle field arithmetic - if diff is greater than half of p, it's actually negative
      if (diff > halfP) {
        diff = diff - p; // Convert back to negative
      } else if (diff < -halfP) {
        diff = diff + p; // Convert back to positive
      }
      
      return sum + diff * diff;
    }, BigInt(0));
  }

  const ssdA1A2 = sumSquaredDifferences(faceA1, faceA2);
  const ssdA1B = sumSquaredDifferences(faceA1, faceB);
  const ssdA2B = sumSquaredDifferences(faceA2, faceB);
  console.debug({ ssdA1A2, ssdA1B, ssdA2B, threshold });
  expect(ssdA1A2).to.be.lessThan(threshold);
  expect(ssdA1B).to.be.greaterThan(threshold);
  expect(ssdA2B).to.be.greaterThan(threshold);
})

it("proves and verifies on-chain", async () => {
  // Deploy the ZFace contract with reference face and threshold
  const contractFactory = await ethers.getContractFactory("ZFace");
  const contract = await contractFactory.deploy(
    await verifierContract.getAddress(), 
    faceA1Bytes,
    thresholdBytes
  );
  await contract.waitForDeployment();

  // Generate a proof
  const { noir, backend } = await hre.noir.getCircuit("zface_verifier");

  
  const input = { 
    probeFace: faceA2.map(v => ({ x: v.toString() })), 
    referenceFace: faceA1.map(v => ({ x: v.toString() })),
    threshold: threshold.toString()
  };
  
  const { witness } = await noir.execute(input);
  const { proof, publicInputs } = await backend.generateProof(witness, {
    keccak: true,
  });
  console.debug({ proof });
  
  // Verify that public inputs match (reference face + threshold)
  expect(publicInputs.length).to.eq(129);

  // Verify the proof on-chain
  const result = await contract.verify(proof);
  expect(result).to.eq(true);

  // You can also verify in JavaScript
  const resultJs = await backend.verifyProof(
    {
      proof,
      publicInputs,
    },
    { keccak: true },
  );
  expect(resultJs).to.eq(true);
});

it("fails verification with different faces", async () => {
  // Deploy the ZFace contract
  const contractFactory = await ethers.getContractFactory("ZFace");
  const contract = await contractFactory.deploy(
    await verifierContract.getAddress(), 
    faceA1Bytes,
    thresholdBytes
  );
  await contract.waitForDeployment();

  // Generate a proof with different probe face
  const { noir, backend } = await hre.noir.getCircuit("zface_verifier");

  const quantizedFaceA = faceA1.map(v => ({ x: v.toString() }));
  const quantizedFaceB = faceB.map(v => ({ x: v.toString() }));
  
  // This should fail in the circuit execution because sum of squared differences > threshold
  await expect(noir.execute({ 
    probeFace: quantizedFaceB, 
    referenceFace: quantizedFaceA,
    threshold: 10 // Low threshold to ensure failure
  })).to.be.rejected;
});